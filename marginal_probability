#
/*

State of the art Approximate inference algorithm on Bayesian networks.

Input:
Bayesian network
No. of samples to generate
wCutSet size (so the maximum number of variables each cluster can have during bucket elimination)
Exact inference value (to compute the error in probability)


Output:
No. of variables conditioned on
Approximate inference value (Marginal Probability)
Error between Exact inference and Approximate inference value

*/


#include "variable_elimination.h"
#include "sampling.h"
#include<utility>
#include<ctime>
#include<map>
#include<sstream>
#include<cstring>
#include<string>
#include<cstddef>
#include<algorithm>
#include<cstdlib>
#include<cstdio>
#include<vector>
using namespace std;


int main(int argc,char** argv){
  int n,d,f,i,k,j;
	int n1;
	long double temp;
	string s;

	//Reading Bayesian / Markov network
	ifstream in(argv[1]);
	in>>s;
	in>>n;
    vector<vector<bool> > edge(n,vector<bool>(n,false));
	//Creating variables of network
	vector<Variable> v;
	for(i=0;i<n;i++){
		in>>d;
		v.push_back(Variable(d,i));
	}
	in>>f;

	//Creating factors of network
	vector<Factor*> master_factors;
	for(i=0;i<f;i++){
		vector<Variable> v_temp;
		in>>n1;
		for(k=0;k<n1;k++){
			in>>j;
			v_temp.push_back(v[j]);
		}
		//cout<<"size"<<v_temp.size()<<"\n";
		set_edge(edge,v_temp);
		master_factors.push_back(new Factor(v_temp));
	}

	//Storing factor values
	for(i=0;i<f;i++){
		vector<long double> t;
		in>>n1;
		for(int j=0;j<n1;j++){
			in>>temp;
			t.push_back((temp));
		}
		master_factors[i]->set(t);
	}

  //Generate Samples
  
  int N = atoi(argv[3]);
  int W = atoi(argv[4]);
  int random_seed = atoi(argv[5]);
  bool uniform = true;
  
  srand(random_seed);
  
  if(strcmp("a",argv[6]) == 0)
      uniform = false;
  
  long double exact_z = atof(argv[7]);
  
  cout<<"N = "<<N<<"\t\t"<<"Width = "<<W<<"\t"<<"Random seed = "<<random_seed<<"\n";
  if(uniform) cout<<"Distribution: Uniform\n";
  else cout<<"Distribution: Adaptive\n";
  
  time_t rawtime;
  time_t rawtime1;
  time ( &rawtime );
  cout<<"Start time: "<<ctime(&rawtime);
  
  long double total_z = 0;
  vector< vector<double> > Q_distribution;
  vector< map<int,int> > samples_upto_t;
  vector<int> var_order;
  vector<int> eliminated_list;
  get_min_order(edge,var_order,eliminated_list);
  //cout<<"Computing w-cutset\n";
  vector<int> cutset_evidence = wCutSet(master_factors,var_order,W);
  sort(cutset_evidence.begin(),cutset_evidence.end());
  vector<long double> w_t;
  cout<<"\tNo of variables conditioned: "<<cutset_evidence.size()<<"\n";
  initialize_Q(Q_distribution,cutset_evidence,v);
  map<string,long double> computed_samples;
  double Q;
  for(int counter = 1; counter <= N; counter++)
  {
  
      if(counter%100 == 0 && counter != 0 && !uniform){
  //        cout<<"\tIteration number: "<<counter<<"\n";
          updateQ(Q_distribution,samples_upto_t,cutset_evidence,w_t);
      }
  
      vector<Factor*> factors;
      vector<vector<bool> > edge(n,vector<bool>(n,false));
      for(i=0; i<master_factors.size(); i++){
          factors.push_back( new Factor(master_factors[i]->get_var(),master_factors[i]->get_table()) );
          set_edge(edge,factors[i]->get_var());
      }
  
      eliminated_list.clear();
      eliminated_list.insert(eliminated_list.begin(),cutset_evidence.begin(),cutset_evidence.end());
  
        //Reading evidence file:
    	int n_evid=0;
    	map<int,int> evid_map;
        //cout<<"Sampling Evidence\n";
        evid_map = sample_evidence(cutset_evidence,v,Q_distribution,random_seed);
        samples_upto_t.push_back(evid_map);
    
    	ifstream file_evid(argv[2]);
    	file_evid>>n_evid;
    	int t,t1;
    	for(i=0;i<n_evid;i++){
    		file_evid>>t;
    		eliminated_list.push_back(t);
    		file_evid>>t1;
    		evid_map[t]=t1;
    	}
  
      n_evid = evid_map.size();
  
      if(counter == 1 || counter %100 == 0)
          Q = compute_Q(Q_distribution,evid_map);
  
        //cout<<"Instantiate Evidence\n";
    	long double z = instantiate_evidence(factors,evid_map);
    
    	//Eliminate variables by min degree order
    	int n1=n-n_evid;
    	while(n1>1){    
        		//Find the variable 'e' with min degree
        		int eliminate = find_min_order(edge,n,eliminated_list);
                eliminated_list.push_back(eliminate);
        
        		//Multiply factors that has the variable 'e'
        		//cout<<"Multiplying factors\n";
        		bool summed_out;
        		long double pr_evid;
        		Factor *temp_factor = multiply_factors(factors,eliminate,factors.size(),evid_map,summed_out,pr_evid);
            if(!summed_out){
                z = z * pr_evid;
                delete(temp_factor);
            }
            else{
                factors.push_back(temp_factor);
                f=factors.size();
                set_edge(edge,temp_factor->variables);
            }
        		remove_edges(edge,eliminate,n);
        		n1--;
    	}
    	long double pr_evid;
    	Factor *temp_factor = multiply_evidence_factors(factors,factors.size(),pr_evid);
      delete(temp_factor);  
      vector<Factor*>::iterator it = factors.begin();
      while(it != factors.end()){
          delete(*it);
          it = factors.erase(it);
      }

      w_t.push_back((pr_evid*z)/Q);
      //cout<<Q<<" "<<w_t[counter-1]<<"\n";
      total_z += w_t[counter-1];
    }
    cout<<"\tProbability of evidence: "<<total_z/N<<"\n";

    cout<<"\tError:"<< 1 - (log(total_z/N) / log(exact_z))<<"\n";

    time ( &rawtime1 );
    cout<<"End time: "<<ctime(&rawtime1);
    cout<<"Processing time: "<<difftime(rawtime1,rawtime)<<"\n\n";

    vector<Factor*>::iterator fit = master_factors.begin();
    while(fit != master_factors.end()){
        delete(*fit);
        fit++;
    }
	return 0;
}


